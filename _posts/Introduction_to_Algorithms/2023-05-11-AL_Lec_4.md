---
layout: article
title: Quicksort, Randomized Algorithms
tags: Introduction_to_Algorithms
aside:
  toc: true
sidebar:
  nav: Introduction_to_Algorithms
---

Today, we will introduce a very interesting Algorithm, called "<b>Quicksort</b>", which was invented by Tony Hoare in 1962. 

* It's also a Divide-and-Conquer Algorithm.

* The array will be sorted "<b>in place</b>". (That means Quicksort doesn't need extra array like Mergesort.)  Therefore, it's fairly efficient in its use of storage.

* Very pratical (with tuning)

<!--more-->

# Idea of Quicksort

1. "Divide": Partition array into 2 subarray arond pivot ${ x }$, such that 

<center>elems in lower subarray ${ \leq x \leq }$ elems in upper subarray</center>

<p align="center">
    <img src="/post_image/Introduction_to_Algorithm/Lec_4/Idea_of_Quicksort.png" width="40%">
</p>

2. "Conquer": Recursively sort the two subarray. 

3. "Combine": Trivial 

So, the key point is te "Divide" Step. We can treat the Quicksort as recursive partitioning, and the Mergesort is recursive merging. Here, we can give a linear time ${ \Theta(n) }$ partiioning subroutine and give its pseoudocode 

{% highlight pseudocode linenos %}
Partitioning(A,p,q): // treat A[p···q]
    x = A[p] // pivot is A[q]
    i = p // set index
    For j = p+1 to q
        if A[j] <= x 
            i = i + 1
            exchange A[i] with A[j]
    exchange A[p] with A[i]
    return i
{% endhighlight %}

# Correctness of Quicksort

Actually, we hold our array with 4 area (but some of them maybe empty), which is also our "<b>invariant</b>". The first area is the first element ${ x }$. And, all the elements of the second area is less than or equal to ${ x }$. The third area include some elements which are greater than ${ x }$. The last area is called "unknown area", the elements in which are undecided. 

In each loop, when we move to next element, we first compare it to ${ x }$, if it's greater than ${ x }$, then we continue move forward. If not, we exchange it with the first element in third area (all the elements in it is greater than ${ x }$). So, in the second situation, the second area is entended by one element, and the hole third area move forward by one element. 

When the index ${ j }$ move to ${ q }$. Then the unknown area is a empty set. At that time, we have three area: ${ x }$, second area (${ \leq x }$) and third area (${ \geq x }$). 

In the end, we exchange the first element ${ A[p], x }$ with the last element of second area. We will find, all the elements which is less than ${ x  }$  list in the left of ${ x }$, and the all the elements greater than ${ x }$ are positioned in the right of the ${ x }$.

<p align="center">
    <img src="/post_image/Introduction_to_Algorithm/Lec_4/Quicksort.png" width="80%">
</p>

It's easy to check the <b>runting time</b> of "<b>Partitioning</b>" is ${ \Theta(n) }$.

# Runing time Analysis

Then we can write down the pseudocode of Qiucksort 

{% highlight pseudocode linenos %}
Quicksort(A,p,q): // treat A[p···q]
    if p < q
        r = Partition(A,p,q)
        Quicksort(A,p,r-1)
        Quicksort(A,r,q)

//Initial Call
Quicksort(A,1,n)
{% endhighlight %}

Here, to analyze the runing  time of Quicksort, we assume all the elements is distinct (not redundant). Let's ${ T(n) }$ be the worst-case runing time. So, if the input array is sorted or reverse sorted, the partitioning is the worst case, becasue one side of the partition has no elements. Here we can right the recursion of Quicksort (the runting time of empty side is ${ T(0) }$, and the another side is ${ T(n-1) }$, the partition time is ${ \theta(n) }$)

<center>$$
\begin{equation}
\begin{aligned}
T(n) &= T(0) + T(n-1) + \theta(n) \\
&= \theta(1) + T(n-1) + \Theta(n) \\
&= T(n-1) + \Theta(n) \\
&= \Theta(n^2)
\end{aligned}
\end{equation}
$$</center>

In general, we don't do best-case analyses, but here we do it for intuition only. If we are in the lucky case, <b>Partition</b> splits the array ${ n/2 : n/2 }$. In this case, the recursion is

<center>$$
\begin{equation}
\begin{aligned}
T(n) &= 2T(n/2) + \Theta(n) \\
&= \Theta(n \lg n)
\end{aligned}
\end{equation}
$$</center>

But, how about <b>Split</b> is always ${ 1/10 : 9/10 }$? We are in lucky or unlucky case? Let's draw a recursion tree for this (denote ${ \Theta(n) }$ as ${ cn }$)

<p align="center">
    <img src="/post_image/Introduction_to_Algorithm/Lec_4/split_1_9.png" width="65%">
</p>

