---
layout: article
title: 文献分享：Assembly of long, error-prone reads using repeat graphs Assembly
tags: papers

article_header:
  type: cover
  image: 
    src: /post_image/Flye/Flye.PNG
---

这篇博客向大家介绍三代基因组组装软件Flye，这是Pavel A. Pevzner在2019年发表在nature biotech上的工作. Flye通过构建repeat gragh来表示基因组，同时在解决repeat问题上提出了一个非常好的思路.<!--more-->

关于repeat graph，大家可以参考这篇博客[文献分享：De Novo Repeat Classification and Fragment Assembly](https://wu-haonan.github.io/2021/07/10/Fragmentgluer.html)，关于三代测序的基因组组装问题，大致有两种思路，一个是“correction then assembly”，一个是“assembly then correction”，Flye采用的策略是先拼接后矫正，我想原因在于不矫正read，保留read的原始信息，才有可能解决unbridged repeat. 具体的原因，请在Methods部分细细品味.

# Methods

为了更细致的理解Flye的思想，以及保持一些术语的统一，再这里我仍然按照Flye的行文思路进行讲解，当然一些思路和结论我们在博客[文献分享：De Novo Repeat Classification and Fragment Assembly](https://wu-haonan.github.io/2021/07/10/Fragmentgluer.html)已经提及. Flye在方法部分，仍然是先介绍repeat characterization problem，然后引出repeat graph来解决repeat characterization problem，最后再给出repeat graph和assembly之间的关系.

## Repeat characterization problem

考虑有向图${G}$和图中的一个长度为${n}$的**tour** ${T=v_1,v_2\cdots,v_n}$，我们称${i}$th和${j}$th顶点是等同的，如果他们对应图中的相同顶点，即${v_i = v_j}$. 这些等同的点${(i,j)}$，我们可以将其绘制在一个二维的网格中，我们称这个网格图为**tour** ${T}$的**repeat plot** ${Plot_T (G)}$. 如果已知${G,T}$，得到**repeat plot** ${Plot_T (G)}$是一个非常容易的问题.

而我们更关注这个问题的反问题，任给一个${Plot}$，来寻找图${G=G(Plot)}$和tour ${T}$.

基因组的dot-plot其实是一个矩阵，可以图表化genome中的所有repeat. 在repeat characterization问题中，我们关注于genome自身的local-alignment，那么每个一self-alignment对应基因组两个连续的repeat片段（segment）${x,y}$，${x}$和${y}$称为该alignment的${spans}$. 给定一个长度为${n}$的genome，以及自身比对的${Plot}$，Repeat characterization problem等价于构建图${G}$以及长度为${n}$的tour ${T}$（基因组的每个segment对应tour ${T}$中的subpath），其中${Plot=Plot(G)}$，tour ${T}$是符合alignment结果的.

## Generating repeat plot of genome

Flye生成基因组的所有self-alignments，然后组合成repeat plot ${Plot}$. 

## Constructing a punctilious repeat graph

令 Alignment = Alignment(Genome,minOverlap)，是基因组‘Genome’中充分长的self-alignment的集合（长度最少是‘minOverlap’）. Flye设置‘minOverlap’为read-set的N90（在这篇文章的数据集中，N90大致是${3000-5000bp}$）

给定了‘Genome’的self-alignment的集合‘Alignment’之后，接下来我们构建punctilious repeat graph，即**一丝不苟的**repeat graph RepeatGraph(Genome,Alignment). 得到的方法就是将‘Alignment’比对上的positions ‘gluing’到一起. 然后将分支顶点之间的simple path收缩为一条边，这条边的长度等于原始path的边的数量. 这个图就是punctilious repeat graph，我们按照阈值${d=500}$，将边分为**long**和**short**.

之所以这样做，是为了下面简化punctilious repeat graph做铺垫，punctilious repeat graph在真实的基因组中会非常复杂，‘gluing’操作会产生许多branching point.

## From punctilious repeat graph to repeat graph

在比对的时候，repeat的端点很难完全对齐，那么在‘gluing’之后，就会产生复杂的结构，比如分支顶点和**short** edge（${<d=500}$）. repeat graph RepeatGraph(Genome,Alignment,${ d }$)定义为将punctilious repeat graph的**short** read收缩之后的图. 具体的收缩操作，就是将边的endpoint进行‘gluing’，然后移除loop-edge. 考虑基因组tour，穿过repeat graph多次的就是repeat edges，一次的称为unique edge.

## Approximate repeat graphs

在FragmentGluer中，花了很多的经历来处理Whirl/Bullbe，但是在三代测序中这些处理的很多参数很难抉择，因此我们采用下面的方法进行处理，只关注于self-alignment的端点.

考虑punctilious repeat graph中导致repeat graph中的branching vertices的顶点集合${V}$，令Breakpoints=Breakpoints(Genome,Alignment,${d}$)，是导致${V}$的基因组的位置集合.

<p align="center">
    <img src="/post_image/Flye/Constructing_repeat_graph.PNG" width="80%">
</p>

__Fig.1 Workf of constructing repeat graph[^1].__

[^1]:图片来源[Assembly of long, error-prone reads using repeat graphs](https://www.nature.com/articles/s41587-019-0072-8)