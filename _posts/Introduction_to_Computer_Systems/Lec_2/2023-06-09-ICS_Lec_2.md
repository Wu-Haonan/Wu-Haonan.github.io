---
layout: article
title: Bits, Bytes, and Integers I
tags: Introduction_to_Computer_Systems
aside:
  toc: true
sidebar:
  nav: Introduction_to_Computer_Systems
---

In this and next couple of blogs, we gonna talking about data representations, how numbers are represented in different forms and some of the properties. We need to understand what is the bit level representation of numbers and how does that affect some of the properties when we operate them on. Especially, we need to pay attention to these corner cases.  

<!--more-->

# Encoding Byte Values

We commonly group collections of <b>4 bits</b> at a time, and represent that in base 16 (hexadecimal representation, ${ 1,2,\cdots,9,A,B,\cdots, F  }$). Using the letters A throught F as values 10 through 15. In C, numeric constants starting with 0x or 0X are interpreted as being in hexadecimal. For example, we could write the number ${ \text{FA1D37B}_{16} }$ as 0xFA1D37B, as 0xfa1d37b, or even mixing upper- and lowercase (e.g., 0xFa1D37b). Note, if the total number of bits is not a multiple of 4, you should make the l<i>eftmost</i> group be the one with fewer than 4 bits, effectively padding the number with leading zeros. Then you translate each group of bits into the corresponding hexadecimal
digit, like 110010, we will pad it as 00110010, that is 0x32. 

Most computers use blocks of 8 bits, or <b>bytes</b>, as the <b>smallest addressable unit</b> of memory. A machine-level program views memory as a very large array of bytes, referred to as <b>virtual memory</b><i></i>. Every byte of memory is identified by a unique number, known as its <i>address</i>, and the set of all possible addresses is known as the <i>virtual address space</i>.

In fact, this virtual address space is just a conceptual image presented to the machine-level program. The actual implementation uses a combination of <i>dynamic random access memory</i> (DRAM), flash memory, disk storage, special hardware, and operating system software to
provide the program with what appears to be a monolithic byte array, which will be talked in latter class.

# Boolean Algebra

* <b>And</b> A&B = 1, when both A = 1 and B = 1

* <b>Or</b> A\|B = 1, when either A = 1 or B = 1
* <b>Not</b> ~A = 1, when A = 0
* <b>Exculsive-Or (Xor)</b> A^B = 1, when A,B are different

Here is a <b>Example</b>, we can use 8 bits to represent a set ${ A }$, the element is ${ 0,\cdots,7 }$. ${  a_j = 1 }$ if ${ j \in A}$. Let's give two sets ${ A_1=\{0，3，5，6\}, A_2=\{0,2,4,6\} }$, we represent it as 

<center>$$
\begin{equation}
\begin{aligned}
&01101001  &A_1 = \{0,3,5,6\}\\
&~~65~~3~~~~0 &\\
\end{aligned}
\end{equation}
$$</center>

<center>$$
\begin{equation}
\begin{aligned}
&01010101  &A_2 = \{0,2,4,6\}\\
&~~6~~4~~2~~0 &\\
\end{aligned}
\end{equation}
$$</center>

And, the Boolean operations can have some specific meaning

* & <b>Intersection</b> 01000001 {0,6}
* \| <b>Union</b> 01111101 {0,2,3,4,5,6}
* ^ <b>Symmetric difference</b> (all the unique elements in each set) {2,3,4,5}
* ~ <b>Complement</b> 10101010 {1,3,5,7}

# Contrast: Logic Operations in <b>C</b>

Actually, &&, \|\|, ! (exclamation mark, or is pronounced as "bang") have different meaning with &, \|, ~ in C. They are <b>logic operation</b> rather than bit operation. 

For &&, \|\|, !, they have following properties

* View 0 as "Flase"
* Anything nonzero as "True"
* Always return 0 or 1
* <font color=red>Early termination</font> (&& and \|\| can be treat as a "lazy" operation, like && will terminate and return 0, when it finds the first element is 0, it doesn't check the following one. Similarly, \|\| will terminate and return 1 when it check the first element is 1.)

Here are some examples (char data type)

* !0x41 ${ \rightarrow }$ 0x00 (0x41 is a nonzero bit pattern, so it represents True. Thus, !0x41 = Flase = 0x00)
* !0x00 ${ \rightarrow }$ 0x01
* !!0x41 ${ \rightarrow }$ 0x01

* 0x69 && 0x55 ${ \rightarrow }$ 0x01 (True && True ${ \rightarrow }$ True = 0x01)
* 0x69 \|\| 0x55 ${ \rightarrow }$ 0x01 (True \|\| True ${ \rightarrow }$ True = 0x01)
* p && *p (By early termination, we can avoid null pointer access)

# Shift Operation

1. Left Shift: x << y

    Shift bit-vector ${ x }$ left ${ y }$ position. 

    * Throw away extra bits on left
    * Fill with 0's on right

2. Right Shift: x >> y

    Shift bit-vector ${ x }$ right ${ y }$ position. Throw away extra bits on right, but for filling on left we have <b>two</b> different way

    * Logical shift: Fill with 0's on left
    * Arithmetric shift: Replicate most significant bit on left

Take an example, x = 01100010, x >> 2

First, we throw away the rightmost two bits, and empty the leftmost two bits as  ${ \Box \Box 011000}$. The second step, for logical way, we get <font color=red>00</font>011000, and for arithmetric way, we get <font color=red>00</font>011000 too, because the first number of remaining part is 0 (<font color=red>0</font>11000). 

Take another example, x = 10100010, x >> 2. 

In this case, we get ${ \Box \Box 100010}$ at first step. So, the most significant bit on left is 1. Therefore, the Arithmetric shift gets <font color=red>11</font>101000








