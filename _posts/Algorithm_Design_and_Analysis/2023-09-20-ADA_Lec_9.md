---
layout: article
title: NP, NP-Complete Problems
tags: Algorithm_Design_and_Analysis
aside:
  toc: true
sidebar:
  nav: Algorithm_Design_and_Analysis
---

Thsi blog is still talking about hardness of problems, focusing on NP, NP-Complete Problems.

<!--more-->

# Definition of NP

The input to a computational problem will be encoded as a finite binary
string ${ s }$. We denote the length of a string s by ${ \vert s \vert }$. 

We will identify <b>a decision problem X with the set of strings on which the answer is “yes.”</b> An algorithm ${ A }$ for a decision problem receives an input string ${ s }$ and <b>returns the value “yes” or “no”</b> — we will denote this returned value by ${ A(s) }$. We say that ${ A }$ solves the problem ${ X }$ if for all strings ${ s }$, we have ${ A(s) = yes }$ if and only if ${ s \in X }$.

we say that ${ A }$ has a <b>polynomial running time</b> if there is a
polynomial function ${ p(\dot) }$ so that for every input string ${ s }$, the algorithm ${ A }$ terminates on ${ s }$ in at most ${ O(p(\vert s \vert)) }$ steps.